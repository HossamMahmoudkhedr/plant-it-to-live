export declare type rollbackFn = () => void;
export interface Options<Input, Data, Error> {
    /**
     * A function to be executed before the mutation runs.
     *
     * It receives the same input as the mutate function.
     *
     * It can be an async or sync function, in both cases if it returns a function
     * it will keep it as a way to rollback the changed applied inside onMutate.
     */
    onMutate?(params: {
        input: Input;
    }): Promise<rollbackFn | void> | rollbackFn | void;
    /**
     * A function to be executed after the mutation resolves successfully.
     *
     * It receives the result of the mutation.
     *
     * If a Promise is returned, it will be awaited before proceeding.
     */
    onSuccess?(params: {
        data: Data;
        input: Input;
    }): Promise<void> | void;
    /**
     * A function to be executed after the mutation failed to execute.
     *
     * If a Promise is returned, it will be awaited before proceeding.
     */
    onFailure?(params: {
        error: Error;
        rollback: rollbackFn | void;
        input: Input;
    }): Promise<void> | void;
    /**
     * A function to be executed after the mutation has resolves, either
     * successfully or as failure.
     *
     * This function receives the error or the result of the mutation.
     * It follow the normal Node.js callback style.
     *
     * If a Promise is returned, it will be awaited before proceeding.
     */
    onSettled?(params: {
        status: 'success';
        data: Data;
        input: Input;
    } | {
        status: 'failure';
        error: Error;
        rollback: rollbackFn | void;
        input: Input;
    }): Promise<void> | void;
    /**
     * If defined as `true`, a failure in the mutation will cause the `mutate`
     * function to throw. Disabled by default.
     */
    throwOnFailure?: boolean;
    /**
     * If defined as `true`, a failure in the mutation will cause the Hook to
     * throw in render time, making error boundaries catch the error.
     */
    useErrorBoundary?: boolean;
}
export declare type Status = 'idle' | 'running' | 'success' | 'failure';
export declare type Reset = () => void;
export declare type MutationResult<Input, Data, Error> = [(input: Input) => Promise<Data | undefined>, {
    status: Status;
    data?: Data;
    error?: Error;
    reset: Reset;
}];
/**
 * Hook to run async function which cause a side-effect, specially useful to
 * run requests against an API
 */
export default function useMutation<Input = any, Data = any, Error = any>(mutationFn: (input: Input) => Promise<Data>, { onMutate, onSuccess, onFailure, onSettled, throwOnFailure, useErrorBoundary, }?: Options<Input, Data, Error>): MutationResult<Input, Data, Error>;
